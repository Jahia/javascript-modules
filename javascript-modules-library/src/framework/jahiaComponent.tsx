import type { JCRValueWrapper } from "org.jahia.services.content";
import type { Bundle } from "org.osgi.framework";
import type { JSX } from "react";
import server from "virtual:jahia-server";
import { type ServerContext, useServerContext } from "../hooks/useServerContext.js";

declare const bundle: Bundle;

export interface JahiaComponent {
  /** The ID of the component (autogenerated but can be overridden) */
  id?: string;
  /**
   * The name of the component.
   *
   * @default "default"
   */
  name?: string;
  /** The display name of the component (in jahia's UI), optional. */
  displayName?: string;
  /** The type of the component. */
  componentType: "template" | "view";
  /** The content node type the component applies to. */
  nodeType: string;
  /**
   * The priority of the components in case multiple templates/views are applicable to a given
   * resource. The component with the highest priority has precedence over the other components.
   *
   * @default 0
   */
  priority?: number;
  /** Properties to add on the component, optional. */
  properties?: Record<string, string>;
}

/**
 * Defines and registers a Jahia component into the global registry as a view.
 *
 * @param id The ID of the component (autogenerated but can be overridden)
 * @param definitions The definitions of the component
 * @param Component The component to register
 */
export const jahiaComponent = <T extends (props: never, context: ServerContext) => JSX.Element>(
  { id, ...definitions }: JahiaComponent,
  Component: T,
): T => {
  const options = {
    name: "default",
    templateType: "html",
    priority: 0,
    component: wrap(Component),
    ...definitions,
  };

  // If id is not provided, generate it using bundleSymbolicName, componentType, nodeType, and name
  // optionally, include the priority if different from the default value (to remain backward compatible)
  id ??= `${bundle.getSymbolicName()}_${options.componentType}_${options.nodeType}_${options.name}${options.priority ? "_" + options.priority : ""}`;

  // Register view
  const reactView = server.registry.get("view", "react");
  server.registry.add("view", id, reactView, options);

  console.debug(`Registered Jahia component: ${id}`);
  return Component;
};

/** Wraps `Component` to retrieve props from the JCR layer and pass them as usual component props. */
const wrap = (Component: (props: never, context: ServerContext) => JSX.Element) => () => {
  // Retrieve the current context
  const context = useServerContext();
  const session = context.currentNode.getSession();

  /** Resolves a JCR reference to a node. */
  const resolveRef = (id: string) => session.getNodeByIdentifier(id);

  /** All possible JCR value unwrappers, by type. */
  const unwrappers = [
    null, // 0: Undefined
    (value: JCRValueWrapper) => value.getString(), // 1: String
    null, // 2: Binary, deprecated
    (value: JCRValueWrapper) => value.getLong(), // 3: Long
    (value: JCRValueWrapper) => value.getDouble(), // 4: Double
    (value: JCRValueWrapper) => value.getString(), // 5: Date. Use string as Date only supports the current system timezone
    (value: JCRValueWrapper) => value.getBoolean(), // 6: Boolean
    (value: JCRValueWrapper) => value.getString(), // 7: Name
    (value: JCRValueWrapper) => value.getString(), // 8: Path
    (value: JCRValueWrapper) => resolveRef(value.getString()), // 9: Reference
    (value: JCRValueWrapper) => resolveRef(value.getString()), // 10: WeakReference
    (value: JCRValueWrapper) => value.getString(), // 11: URI
    (value: JCRValueWrapper) => value.getString(), // 12: Decimal
  ];

  /**
   * The props of the component.
   *
   * We use a `Proxy` to automatically retrieve the props from the JCR layer, and properly unwrap
   * them.
   */
  const props = new Proxy({} as never, {
    get: (_, key) => {
      if (typeof key !== "string") {
        throw new Error("Invalid prop type");
      }

      if (!context.currentNode.hasProperty(key)) {
        console.debug(`Property not found: ${key}`);
        return undefined;
      }
      const property = context.currentNode.getProperty(key);
      const unwrapper = unwrappers[property.getType()];
      if (!unwrapper) {
        throw new Error(`Unknown JCR property type: ${property.getType()}`);
      }

      return property.isMultiple()
        ? property.getValues().map((value) => unwrapper(value))
        : unwrapper(property.getValue());
    },
    ownKeys() {
      const propertiesIterator = context.currentNode.getProperties();
      const keys = [];
      while (propertiesIterator.hasNext()) {
        const property = propertiesIterator.nextProperty();
        keys.push(property.getName());
      }
      return keys;
    },
    getOwnPropertyDescriptor() {
      return { enumerable: true, configurable: true };
    },
    has(target, key) {
      if (typeof key !== "string") {
        return false;
      }
      return context.currentNode.hasProperty(key);
    },
  });

  return Component(props, context);
};
