import type Lib from "@jahia/javascript-modules-library-private";
import { server } from "@jahia/javascript-modules-library-private";
import { useServerContext } from "../hooks/useServerContext.js";
import type { JCRValueWrapper } from "org.jahia.services.content";
import type { Bundle } from "org.osgi.framework";
import { JSX } from "react";

declare const bundle: Bundle;

export interface JahiaComponent {
  /** The ID of the component (autogenerated but can be overridden) */
  id?: string;
  /**
   * The name of the component.
   *
   * @default "default"
   */
  name?: string;
  /** The display name of the component (in jahia's UI), optional. */
  displayName?: string;
  /** The type of the component. */
  componentType: "template" | "view";
  /** The content node type the component applies to. */
  nodeType: string;
  /** Properties to add on the component, optional. */
  properties?: Record<string, string>;
}

/**
 * Defines and registers a Jahia component into the global registry as a view.
 *
 * @param id The ID of the component (autogenerated but can be overridden)
 * @param props The properties of the component
 * @param Component The component to register
 */
export const jahiaComponent = <T extends (props: never, context: Lib.ServerContext) => JSX.Element>(
  { id, ...props }: JahiaComponent,
  Component: T,
): T => {
  const options = {
    name: "default",
    templateType: "html",
    component: wrap(Component),
    ...props,
  };

  // If id is not provided, generate it using bundleSymbolicName, componentType, nodeType, and name
  id ??= `${bundle.getSymbolicName()}_${options.componentType}_${options.nodeType}_${options.name}`;

  // Register view
  const reactView = server.registry.get("view", "react");
  server.registry.add("view", id, reactView, options);

  console.log(`Registered Jahia component: ${id}`);
  return Component;
};

/** Wraps `Component` to retrieve props from the JCR layer and pass them as usual component props. */
const wrap = (Component: (props: never, context: Lib.ServerContext) => JSX.Element) => () => {
  // Retrieve the current context
  const context = useServerContext();
  const session = context.currentNode.getSession();

  /** Resolves a JCR reference to a node. */
  const resolveRef = (id: string) => session.getNodeByIdentifier(id);

  /** All possible JCR value unwrappers, by type. */
  const unwrappers = [
    null, // 0: Undefined
    (value: JCRValueWrapper) => value.getString(), // 1: String
    null, // 2: Binary, deprecated
    (value: JCRValueWrapper) => value.getLong(), // 3: Long
    (value: JCRValueWrapper) => value.getDouble(), // 4: Double
    (value: JCRValueWrapper) => value.getString(), // 5: Date
    (value: JCRValueWrapper) => value.getBoolean(), // 6: Boolean
    (value: JCRValueWrapper) => value.getString(), // 7: Name
    (value: JCRValueWrapper) => value.getString(), // 8: Path
    (value: JCRValueWrapper) => resolveRef(value.getString()), // 9: Reference
    (value: JCRValueWrapper) => resolveRef(value.getString()), // 10: WeakReference
    (value: JCRValueWrapper) => value.getString(), // 11: URI
    (value: JCRValueWrapper) => value.getString(), // 12: Decimal
  ];

  /**
   * The props of the component.
   *
   * We use a `Proxy` to automatically retrieve the props from the JCR layer, and properly unwrap
   * them.
   */
  const props = new Proxy({} as never, {
    get: (_, key) => {
      if (typeof key !== "string") {
        throw new Error("Invalid prop type");
      }

      const property = context.currentNode.getProperty(key);
      const unwrapper = unwrappers[property.getType()];
      if (!unwrapper) {
        throw new Error(`Unknown JCR property type: ${property.getType()}`);
      }

      return property.isMultiple()
        ? property.getValues().map((value) => unwrapper(value))
        : unwrapper(property.getValue());
    },
  });

  return Component(props, context);
};
